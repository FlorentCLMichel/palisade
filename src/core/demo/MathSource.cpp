/*
 * @author  TPOC: palisade@njit.edu
 *
 * @copyright Copyright (c) 2017, New Jersey Institute of Technology (NJIT)
 * All rights reserved.
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice, this
 * list of conditions and the following disclaimer in the documentation and/or other
 * materials provided with the distribution.
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
 * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

// This is a main() file built to test math  operations
// D. Cousins

#define PROFILE // need to define in order to turn on timing reporting

#include <iostream>
#include <fstream>
#include "utils/inttypes.h"
#include "math/backend.h"
#include "math/nbtheory.h"
#include "math/distrgen.h"
#include "lattice/elemparams.h"
#include "lattice/ilparams.h"
#include "lattice/ildcrtparams.h"
#include "lattice/ilelement.h"
#include "time.h"
#include <chrono>
#include <exception>
#include "utils/debug.h"
#include <omp.h> //open MP header

using namespace std;
using namespace lbcrypto;


//define the main sections of the test

void test_BigVector(usint nloop); // test old version of big int vector
void test_ubintvec(usint nloop);	 // test new vector version


//main()   need this for Kurts' makefile to ignore this.
int main(int argc, char* argv[]){
  usint nloop = 10;
  if (argc >1)
    nloop = atoi(argv[1]);

  if (nloop < 1) nloop = 1;
  cout <<"running "<<argv[0]<<" nloop = "<<nloop<<endl;

  test_BigVector(nloop);
  return 0;
}

//Testing macro runs the desired code 
// res = fn
// an a loop nloop times, timed with timer t with res compared to testval

#define TESTIT(t, res, fn, testval, nloop) do {	\
    try {								\
      TIC(t);								\
      for (usint j = 0; j< nloop; j++){					\
	res = (fn);							\
      }									\
      time2 = TOC(t);							\
      PROFILELOG(#t << ": " << nloop << " loops " << #res << " = " << #fn << " computation time: " << "\t" << time2 << " us"); \
      if (res != testval){						\
	cout << "Bad " << #res << " = " << #fn << endl;			\
	  /*vec_diff(res, testval);*/					\
      }									\
    }catch(exception & e) {cout<< #res << " = " << #fn << " caught exception "<< e.what() <<endl;} \
  } while (0);


//helper function that bulds BigVector from a vector of strings
BigVector BBVfromStrvec( std::vector<std::string> &s) {
  BigVector a(s.size());
  for (usint i = 0; i< s.size(); i++){
    a.at(i)=s[i];
  }
  return a;
}

//function to compare two BigVectors and print differing indicies
void vec_diff(BigVector &a, BigVector &b) {
    for (usint i= 0; i < a.GetLength(); ++i){  
      if (a.at(i) != b.at(i)) {
        cout << "i: "<< i << endl;
	cout << "first vector " <<endl;
        cout << a.at(i);
        cout << endl;
	cout << "second vector " <<endl;
        cout << b.at(i);
        cout << endl;

      }
    }

}


//main BigVector test suite. tests math
void test_BigVector (usint nloop) {
  cout<<"testing BigVector"<<endl;

  TimeVar t1,t2,t3,t_total; // timers for TIC() TOC()
  double time2;

  //there are three test cases, 1) small modulus 2)approx 48 bits. 3)
  //very big numbers

  //note this fails BigInteger q1 = {"00000000000000163841"};
  BigInteger q1 ("00000000000000163841");

  // for each vector, define a, b inputs as vectors of strings
  std::vector<std::string> a1strvec = {
    "00000000000000127753", "00000000000000077706",
    "00000000000000017133", "00000000000000022582",
    "00000000000000112132", "00000000000000027625",
    "00000000000000126773", "00000000000000008924",
    "00000000000000125972", "00000000000000002551",
    "00000000000000113837", "00000000000000112045",
    "00000000000000100953", "00000000000000077352",
    "00000000000000132013", "00000000000000057029", };

  // this fails too!!! BigVector a1(a1string);
  // so I wrote this function
  BigVector a1 = BBVfromStrvec(a1strvec);
  a1.SetModulus(q1);

  //b:
  std::vector<std::string> b1strvec = 
    { "00000000000000066773", "00000000000000069572",
      "00000000000000142134", "00000000000000141115",
      "00000000000000123182", "00000000000000155822",
      "00000000000000128147", "00000000000000094818",
      "00000000000000135782", "00000000000000030844",
      "00000000000000088634", "00000000000000099407",
      "00000000000000053647", "00000000000000111689",
      "00000000000000028502", "00000000000000026401", };
  
  BigVector b1  = BBVfromStrvec(b1strvec);
  b1.SetModulus(q1);
  
  //now test all mod functions Note BigVector implies modulus ALWAYS

  //load correct values of math functions of a and b
  //modadd:
  std::vector<std::string>  modsum1strvec =
    {"00000000000000030685", "00000000000000147278",
     "00000000000000159267", "00000000000000163697",
     "00000000000000071473", "00000000000000019606",
     "00000000000000091079", "00000000000000103742",
     "00000000000000097913", "00000000000000033395",
     "00000000000000038630", "00000000000000047611",
     "00000000000000154600", "00000000000000025200",
     "00000000000000160515", "00000000000000083430", };
  BigVector modsum1 = BBVfromStrvec(modsum1strvec);
  modsum1.SetModulus(q1);
  
  
  // modsub:
  std::vector<std::string>  moddiff1strvec =
    {   "00000000000000060980", "00000000000000008134",
	"00000000000000038840", "00000000000000045308",
	"00000000000000152791", "00000000000000035644",
	"00000000000000162467", "00000000000000077947",
	"00000000000000154031", "00000000000000135548",
	"00000000000000025203", "00000000000000012638",
	"00000000000000047306", "00000000000000129504",
	"00000000000000103511", "00000000000000030628", };
  BigVector moddiff1 = BBVfromStrvec(moddiff1strvec);
  moddiff1.SetModulus(q1);
  //modmul:
  
  std::vector<std::string> modmul1strvec =
    { "00000000000000069404", "00000000000000064196",
      "00000000000000013039", "00000000000000115321",
      "00000000000000028519", "00000000000000151998",
      "00000000000000089117", "00000000000000080908",
      "00000000000000057386", "00000000000000039364",
      "00000000000000008355", "00000000000000146135",
      "00000000000000061336", "00000000000000031598",
      "00000000000000025961", "00000000000000087680", };
  
  
  BigVector modmul1 = BBVfromStrvec(modmul1strvec);
  modmul1.SetModulus(q1);

  BigVector c1,c2,c3;	// result vectors

  // compute results for each function and compare.

#if 1
  TESTIT(t1, c1, a1 + b1, modsum1, nloop);
  TESTIT(t1, c1, a1.ModAdd(b1), modsum1, nloop);
  TESTIT(t1, c1, a1 - b1, moddiff1, nloop);
  TESTIT(t1, c1, a1.ModSub(b1), moddiff1, nloop);
  TESTIT(t1, c1, a1 * b1, modmul1, nloop);
  TESTIT(t1, c1, a1.ModMul(b1), modmul1, nloop);
#endif
  //test case 2
  BigInteger q2 ("00004057816419532801");

  std::vector<std::string> a2strvec = {
    "00000185225172798255", "00000098879665709163",
    "00003497410031351258", "00004012431933509255",
    "00001543020758028581", "00000135094568432141",
    "00003976954337141739", "00004030348521557120",
    "00000175940803531155", "00000435236277692967",
    "00003304652649070144", "00002032520019613814",
    "00000375749152798379", "00003933203511673255",
    "00002293434116159938", "00001201413067178193", };

  BigVector a2 = BBVfromStrvec(a2strvec);
  a2.SetModulus(q2);

  std::vector<std::string> b2strvec = 
    { "00000698898215124963", "00000039832572186149",
      "00001835473200214782", "00001041547470449968",
      "00001076152419903743", "00000433588874877196",
      "00002336100673132075", "00002990190360138614",
      "00000754647536064726", "00000702097990733190",
      "00002102063768035483", "00000119786389165930",
      "00003976652902630043", "00003238750424196678",
      "00002978742255253796", "00002124827461185795", };

  BigVector b2 = BBVfromStrvec(b2strvec);
  b2.SetModulus(q2);

  std::vector<std::string> modsum2strvec =
    {"00000884123387923218", "00000138712237895312",
     "00001275066812033239", "00000996162984426422",
     "00002619173177932324", "00000568683443309337",
     "00002255238590741013", "00002962722462162933",
     "00000930588339595881", "00001137334268426157",
     "00001348899997572826", "00002152306408779744",
     "00000294585635895621", "00003114137516337132",
     "00001214359951880933", "00003326240528363988", };
  BigVector modsum2 = BBVfromStrvec(modsum2strvec);
  modsum2.SetModulus(q2);
  
  std::vector<std::string>  moddiff2strvec =
    {   "00003544143377206093", "00000059047093523014",
	"00001661936831136476", "00002970884463059287",
	"00000466868338124838", "00003759322113087746",
	"00001640853664009664", "00001040158161418506",
	"00003479109686999230", "00003790954706492578",
	"00001202588881034661", "00001912733630447884",
	"00000456912669701137", "00000694453087476577",
	"00003372508280438943", "00003134402025525199", };
  BigVector moddiff2 = BBVfromStrvec(moddiff2strvec);
  moddiff2.SetModulus(q2);
  
  std::vector<std::string> modmul2strvec =
    { "00000585473140075497", "00003637571624495703",
      "00001216097920193708", "00001363577444007558",
      "00000694070384788800", "00002378590980295187",
      "00000903406520872185", "00000559510929662332",
      "00000322863634303789", "00001685429502680940",
      "00001715852907773825", "00002521152917532260",
      "00000781959737898673", "00002334258943108700",
      "00002573793300043944", "00001273980645866111", };

  BigVector modmul2 = BBVfromStrvec(modmul2strvec);
  modmul2.SetModulus(q2);
#if 1
  TESTIT(t2, c2, a2+b2, modsum2, nloop);
  TESTIT(t2, c2, a2.ModAdd(b2), modsum2, nloop);
  TESTIT(t2, c2, a2-b2, moddiff2, nloop);
  TESTIT(t2, c2, a2.ModSub(b2), moddiff2, nloop);
  TESTIT(t2, c2, a2*b2, modmul2, nloop);
  TESTIT(t2, c2, a2.ModMul(b2), modmul2, nloop);
#endif

  //test case 3

  //q3: very large numbers.
  BigInteger q3("3273390607896141870013189696827599152216642046043064789483291368096133796404674554883270092325904157150886684127560071009217256545885393053328527589431");

  std::vector<std::string> a3strvec = {
    "2259002487796164904665772121894078584543401744155154298312726209247751689172189255653866355964200768484575418973864307364757237946940733747446643725054",
    "1478743816308009734668992873633380110912159803397999015955212019971253231528589466789603074746010444199132421555598329082557053986240265071537647362089",
    "2442250766561334341166822783674395133995556495312318016431141348749482739749788174173081312927274880146329980363424977565638001056841245678661782610982",
    "917779106114096279364098211126816308037915672568153320523308800097705587686270523428976942621563981845568821206569141624247183330715577260930218556767",
    "214744931049447103852875386182628152420432967632133352449560778740158135437968557572597545037670326240142368149137864407874100658923913041236510842284",
    "3022931024526554241483841300690432083112912011870712018209552253068347592628043101662926263810401378532416655773738499681026278335470355055192240903881",
    "2177879458107855257699914331737144896274676269055062432826552808869348125407671199582563543692287114712642299482144959316835614426673048987634699368975",
    "297233451802123294436846683552230198845414118375785255038220841170372509047202030175469239142902723134737621108313142071558385068315554041062888072990"
  };

  BigVector a3 = BBVfromStrvec(a3strvec);
  a3.SetModulus(q3);

  std::vector<std::string> b3strvec = { 
    "1746404952192586268381151521422372143182145525977836700420382237240400642889251297954418325675184427789348433626369450669892557208439401215109489355089",
    "220598825371098531288665964851212313477741334812037568788443848101743931352326362481681721872150902208420539619641973896119680592696228972313317042316",
    "1636408035867347783699588740469182350452165486745277203525427807971352063169622066488977229506420856017031482691439089288020262006748233954177669740311",
    "1391860681743495586446518646883933051685658718352722633694285758474124803847473349064660555618847951719510263829699292297119131926436045214364252430665",
    "840450278810654165061961485691366961514650606247291814263792869596294713810125269780258316551932763106025157596216051681623225968811609560121609943365",
    "2329731862150094912355786583702878434766436140738594274867891494713002534085652731920888891507522355867974791619686673574928137376468103839586921126803",
    "3059472316627396548271906051517665887700234192652488639437431254697285170484189458770168152800520702020313091234437806236204196526193455750117363744648",
    "132216870748476988853044482759545262615616157934129470128771906579101230690441206392939162889560305016204867157725209170345968349185675785497832527174"
  };

  BigVector b3 = BBVfromStrvec(b3strvec);
  b3.SetModulus(q3);

  std::vector<std::string> modsum3strvec =
    {
      "732016832092609303033733946488851575508905224089926209249817078392018535656765998725014589313481039123037168472673687025432538609494741909227605490712",
      "1699342641679108265957658838484592424389901138210036584743655868072997162880915829271284796618161346407552961175240302978676734578936494043850964404405",
      "805268194532540254853221827315978332231079936014530430473277788624701006514735685778788450107791579012474778927303995844441006517704086579510924761862",
      "2309639787857591865810616858010749359723574390920875954217594558571830391533743872493637498240411933565079085036268433921366315257151622475294470987432",
      "1055195209860101268914836871873995113935083573879425166713353648336452849248093827352855861589603089346167525745353916089497326627735522601358120785649",
      "2079272278780507283826438187565711365662706106566241503594152379685216330309021278700545062992019577249504763265865102246737159166053065841450634441253",
      "1963961166839109935958630686427211631758268415664486282780692695470499499487186103469461604166903659582068706589022694543822554406981111684423535524192",
      "429450322550600283289891166311775461461030276309914725166992747749473739737643236568408402032463028150942488266038351241904353417501229826560720600164",
    };
  BigVector modsum3 = BBVfromStrvec(modsum3strvec);
  modsum3.SetModulus(q3);
  
  std::vector<std::string>  moddiff3strvec =
    {
      "512597535603578636284620600471706441361256218177317597892343972007351046282937957699448030289016340695226985347494856694864680738501332532337154369965",
      "1258144990936911203380326908782167797434418468585961447166768171869509300176263104307921352873859541990711881935956355186437373393544036099224330319773",
      "805842730693986557467234043205212783543391008567040812905713540778130676580166107684104083420854024129298497671985888277617739050093011724484112870671",
      "2799309032266742562930769261070482408568899000258495476312314409719714580243471729247586479328620187276945241504429920336345307950164925099894493715533",
      "2647685260134934808804103597318860343122424407427906327669059277239997218032517842675609320811641720285003894680481883735468131235997696534443428488350",
      "693199162376459329128054716987553648346475871132117743341660758355345058542390369742037372302879022664441864154051826106098140959002251215605319777078",
      "2391797749376600579441197977047078160791084122445638582872412922268196751328156295695665483217670569843215892375267224089848674446364986290845863213758",
      "165016581053646305583802200792684936229797960441655784909448934591271278356760823782530076253342418118532753950587932901212416719129878255565055545816",
    };
  BigVector moddiff3 = BBVfromStrvec(moddiff3strvec);
  moddiff3.SetModulus(q3);
  
  std::vector<std::string> modmul3strvec =
    { 
      "1031054745145843056820705945780914118282144310817341310210020640625431998591940403233545109350272933868060509405157360000389345101372898822036359679625",
      "39893990336327654775086201222472749396440031633689107793562292818341559091551650098949141027412374031231642492390533436782802979527602128674296589001",
      "1281575364673380787247887100773933340217543950815953588352031340354110014040347164387450177246143958852636145466379632479296531828035602618716943463922",
      "8876626876958332707488109358602242636976932642794865821404042110211562924605397999217054754859843534043902943791892973269404255881395585577402022234",
      "1216222886905600696846574145744495331189790230286057979942862366975568127231919204120976315097923349074161373380531458334894968146858459205019035261534",
      "753004725575957473234700352714317139479193934162886068369016394155680048439319699359431951178436867519868720662245420487511271148333130090416613227734",
      "2781700410947724700353568488987777429973246834920346616320143955645243949889536315043352628634199412806795883041065539549687937536501039961931401092055",
      "477574462920419903543345320561430691498452711801747910227743781056369739411065806345235440677935972019383967954633150768168291144898135169751571023658",
    };

  BigVector modmul3 = BBVfromStrvec(modmul3strvec);
  modmul3.SetModulus(q3);

#if 1
  TESTIT(t3, c3, a3+b3, modsum3, nloop);
  TESTIT(t3, c3, a3.ModAdd(b3), modsum3, nloop);
  TESTIT(t3, c3, a3-b3, moddiff3, nloop);
  TESTIT(t3, c3, a3.ModSub(b3), moddiff3, nloop);
#endif
  TESTIT(t3, c3, a3*b3, modmul3, nloop);
  TESTIT(t3, c3, a3.ModMul(b3), modmul3, nloop);

  return;
}
